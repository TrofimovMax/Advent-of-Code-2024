# Условие задачи

## День 3: Разберись с этим

«Наши компьютеры снова барахлят, поэтому я даже не знаю, есть ли у нас Главные Историки на складе! Но вы можете проверить склад сами», — говорит слегка взволнованный продавец в Прокатном магазине саней на Северном полюсе. Историки отправляются на осмотр.

Продавец оборачивается к вам: «Может быть, вы можете понять, почему наши компьютеры снова дают сбой?»

Компьютер, похоже, пытается запустить программу, но его память (ваш ввод) повреждена. Все инструкции перемешаны!

Кажется, цель программы состоит в том, чтобы перемножить несколько чисел. Это делается с помощью инструкций вида `mul(X,Y)`, где `X` и `Y` — это числа от 1 до 3 цифр. Например:
- `mul(44,46)` умножает **44** на **46**, давая результат **2024**.
- `mul(123,4)` умножает **123** на **4**.

Однако из-за повреждений памяти в программе содержатся многие недопустимые символы, которые следует игнорировать, даже если они выглядят как часть инструкции `mul`. Последовательности вида:
- `mul(4*`
- `mul(6,9!`
- `?(12,34)`
- `mul ( 2 , 4 )`
ничего не делают.

### Пример:

Рассмотрим следующий фрагмент повреждённой памяти:

```
xmul(2,4)%&mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))
```


Только следующие четыре секции являются корректными инструкциями `mul`:
- `mul(2,4)` → **2 × 4 = 8**
- `mul(5,5)` → **5 × 5 = 25**
- `mul(11,8)` → **11 × 8 = 88**
- `mul(8,5)` → **8 × 5 = 40**

Сложив результаты этих инструкций, мы получим:
8 + 25 + 88 + 40 = 161


## Задача

Просканируйте повреждённую память в поисках корректных инструкций `mul`. **Какую сумму вы получите, сложив результаты всех умножений?**

# Условие задачи

## Часть 2

Во время сканирования повреждённой памяти вы замечаете, что некоторые условные выражения тоже остались нетронутыми. Если обработать эти корректные условные выражения в программе, вы сможете получить ещё более точный результат.

### Новые инструкции

Теперь вам нужно обработать две новые инструкции:

- **`do()`** — включает будущие инструкции `mul`.
- **`don't()`** — отключает будущие инструкции `mul`.

Применяется только самая последняя инструкция `do()` или `don't()`. В начале программы инструкции `mul` включены.

### Пример:

```
xmul(2,4)&mul[3,7]!^don't()_mul(5,5)+mul(32,64](mul(11,8)undo()?mul(8,5))
```


Этот фрагмент повреждённой памяти похож на предыдущий пример, но в данном случае инструкции `mul(5,5)` и `mul(11,8)` отключены, потому что перед ними находится инструкция `don't()`. Другие инструкции `mul` выполняются, включая последнюю, которая снова включается с помощью инструкции `do()`.

Корректные инструкции:
- `mul(2,4)` → **2 × 4 = 8** (включена).
- `don't()` → отключает инструкции.
- `mul(5,5)` → игнорируется.
- `mul(32,64)` → игнорируется.
- `do()` → включает инструкции.
- `mul(8,5)` → **8 × 5 = 40** (включена).

### Итоговый результат:
8 + 40 = 48

## Задача

Обработайте новые инструкции и посчитайте сумму результатов только для включённых инструкций `mul`. **Какую сумму вы получите?**
